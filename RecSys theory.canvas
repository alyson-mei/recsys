{
	"nodes":[
		{"id":"90ee64d13b6d0811","type":"text","text":"## L1\n\n### Определения и сеттинг\n\n**Постановка задачи**\n$U$ - пространство пользователей, $I$ - пространство айтемов для рекомендации; List($I$) - множество списков айтемов\n\nНеобходимо построить **систему рекомендаций** $y: U \\to \\textrm{List}(I)$\n\nПример: история взаимодействий с айтемами (**фидбэк**); $R_u = (r_{ui})_{i \\in I_u}$ \n\n**Explicit feedback**:\n- Явное отношение пользователя к айтему\n- Меньше данных, сложнее получать\n- Есть подводные камни с интерпретируемостью\n\n**Implicit feedback**: \n- Неявное отношение к айтему (покупка товара, просмотр статьи, время просмотра видео, etc.)\n- Много данных, но меньше доверия\n\n### Подходы\n\n**Коллаборативная фильтрация** \n- Идея: рекомендуем пользователю айтемы, понравившиеся похожим на него пользователям / рекомендуем айтемы, похожие на понравившиеся пользователю\n- В общем смысле - семейство методов рекомендаций, основанных на похожестях по истории взаимодействия между пользователями и товарами\n\n**User2User**\n- $s(u,v)$ - мера похожести. $N(u) = \\lbrace v \\in U - \\lbrace u \\rbrace | s(u,v) > \\alpha \\rbrace$ - похожие на данного пользователи\n- Предлагаем пользователю айтемы, котоые понравились похожим на него пользователям\n- Оценив рейтинг непросмотренных айтемов, порекомендуем некоторое кол-во айтемов с максимальной оценкой\n\n\n$$\\hat{r}_{ui} = \\bar{r}_u + \\sigma_u\\frac{\\sum_{v \\in N(u)}s(u,v)r_{vi}/\\sigma_{uv}}{\\sum_{v \\in N(u)}|s(u,v)|}, \\ \\sigma_u = \\sqrt{\\frac{1}{|l_u}\\sum_{i \\in I_u} (r_{ui}-r_u)^2}$$\nВыбор $s(u, v)$\n- Мера Жаккара $s(u,v) = |I_u \\cap I_v| / |I_u \\cup I_v|$\n- Скалярное произведение $s(u,v) = \\sum_{i \\in I_u \\cap I_v} r_{ui}r_{vi}$\n- Корреляция Пирсона между векторами общих рейтингов (+ с поправкой на случай малого числа общего рейтинга)\n\n**Item2Item**\n**Идея**: к оцененным пользователем товаы найдём наиболее похожие на них и порекомендуем\nПохожесть - косинусная мера с поправкой на средний рейтинг пользователей:\n$$\\frac{\\sum_{u \\in U_i \\cap U_j}(r_{ui}-\\bar{r}_u)(r_{uj}-\\hat{r}_u)}{\\sqrt{\\sum_{u \\in U_i \\cap U_j} (r_{ui}-\\bar{r}_u)^2}\\sqrt{\\sum_{u \\in U_i \\cap U_j} (r_{uj}-\\bar{r}_u)^2}}$$\nДля позитивного фидбэка термин **позитивы**\nItem2Item приоритетнее в проде (часто у пользователей мало лайков, и нужно пересчитывать всё, если добавилось небольшое количество)\n\n**Использование признаков пользователей**\n\n**Отбор кандидатов** - уменьшение с исходного огромного количества\n- Эвристики\n- Коллаборативные\n- Контентные похожести\n- Бизнес-логика (новое, промо, etc.)\n\n**Реранкинг**: ограничение количества старых/слишком длинных видео, разнообразие\n\n**Пайплайн**: База документов -> отбор кандидатов -> ранжирование -> финальная рекомендация\n\n**Проблема холодного старта**\n\n","x":-680,"y":-180,"width":880,"height":1800},
		{"id":"87e6b0e699573e7d","type":"text","text":"## L2\n\n### Recap\n\n- Коллаборативные модели - основанные на сигнале от пользователей\n- Контентные модели - основанные на сигнале от самих айтемов, не привязанные к информации о взамодействии всех пользователей со всеми айтемами \n\nUser2User:\n- Используется с кластеризацией пользователей\n- Может быть более актуально, чем Item2Item, если пользователи более стабильны\n\n### PCA, SVD, Truncated SVD\n\n**PCA**: снижнение числа признаков, новые - линейная комбинация старых\n\n**SVD**: $R = U\\Sigma V^T$, $UU^T = I_M, VV^T = I_N$ \n$R: (M, N) = U: (M, M) \\cdot \\Sigma: (M, N) \\cdot V^T: (N, N)$ \n**SVD Compact**\n**Truncated SVD**\n\n**Truncated SVD as optimization**\n$$\\min \\sum_{i,j}(r_{ij}-x_i^Ty_j)^2 + \\lambda \\sum_i ||x_i||^2 C_i + \\lambda \\sum_j ||y_j||^2 C_j$$\n$$C_i = \\frac{|\\lbrace j|r_{ij}>0\\rbrace |^\\alpha |\\lbrace i \\rbrace|}{|\\lbrace j|r_{ij}>0\\rbrace |^\\alpha}$$\n\n**Funk SVD**\n\n**ALS** - метод оптимизации\n**IALS**","x":260,"y":-180,"width":760,"height":960},
		{"id":"43b24d1e30f53120","x":1160,"y":-180,"width":680,"height":1020,"type":"text","text":"## L3\n\n### Recap\n\n### SLIM - Sparse Linear Methods\n**Сеттинг**\n- $A$ - бинарная (пусть) матрица $M \\times N$ интеракций user-item\n- Определим $a_{ui}$ взаимодействие как взвешивание событий прошлого:\n$$\\hat{a}_{ui} = \\sum_{j=1}^N w_{ij} a_{uj}$$\n$\\hat{a}_{ui}$ - оценка взаимодействия пользователя $u$ и $i$ \nТребуется: \n- $w_{ij} \\geq 0$; модель учитывает только схожие атомы \n- $w_{ii} = 0$  - исключение элементарного решения $W = I_n$\n- $w_{ij}$ - некоторая мера похожести $j$-го товара на $i$-й\nВ общем, что-то похожее на разложения по базису\n\n**Оптимизируем MSE с Elastic Net**\n$$\\frac{1}{2}\\sum_{u,i} (a_{ui}-\\sum_{j}w_{ij}a_{uj})^2 + \\lambda \\sum_{i,j}|w_{ij}| + \\frac{\\beta}{2} \\sum_{i,j}(w_{ij})^2 \\to \\min_W$$Распадается на $m$ задач, если фиксируем $i$\n\n**Как теперь делать рекомендации**\n1. Берём вектор взаимодействий пользователя $A_u$\n2. Считаем $\\hat{a}_{ui}$ для всех новых айтемов \n3. Сортируем новые айтемы по $\\hat{a}_{ui}$ и берём топ продуктов с наибольшим value\n\n**Замечание**: Матрица $W$ будет будет"}
	],
	"edges":[]
}